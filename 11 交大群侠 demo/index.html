<!doctype html>
<meta charset="utf-8">
<title>交大</title>
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1, maximum-scale=1, user-scalable=0">
<!-- 这meta的作用就是删除默认的苹果工具栏和菜单栏 -->
<meta name="mobile-web-app-capable" content="yes">
<style>
  body {
    margin: 0; padding: 0;
    overflow: hidden;
    background-color: #000;
  }
  @font-face {
    font-family: 'Conv_monogram';
    src: url('fonts/monogram.eot');
    src: local('☺'), url('fonts/monogram.woff') format('woff'), url('fonts/monogram.ttf') format('truetype'), url('fonts/monogram.svg') format('svg');
    font-weight: normal;
    font-style: normal;
  }
  @font-face {
    font-family: 'Conv_Minecraftia-Regular';
    src: url('fonts/Minecraftia-Regular.eot');
    src: local('☺'), url('fonts/Minecraftia-Regular.woff') format('woff'), url('fonts/Minecraftia-Regular.ttf') format('truetype'), url('fonts/Minecraftia-Regular.svg') format('svg');
    font-weight: normal;
    font-style: normal;
  }
</style>
<script src="./js/webfontloader.js"></script>
<script src="./js/sound.js"></script>
<script>
  WebFont.load({
    custom: {
      families: ['Conv_monogram','Conv_Minecraftia-Regular']
    }
  });
</script>
<script src="./js/pixi.min.js"></script>
<body></body>

<script>

  //var w = 375;//这个是iphone6-x 的宽度
  //var h = 600;
  var w = 750;
  var h = 1200;
  var mySound;


  //这个是很重要的一个函数，用于 app.ticker 之中。
  //当 myTicker 赋予不同的处理函数的时候，就会对对应的函数处理
  //而不被处理的内容，状态就不会被改变，就好像被“暂停了”一样
  //所以所谓的“暂停”，无非就是某个场景的状态不被改变而已。
  //我之前在研究“faerieFM”的暂停的时候，一直找不到“暂停”的操作，后来一一排查，才恍然大悟！
  var myTicker = function(){}

  //创建实例
  var app = new PIXI.Application({width:w,height: h,backgroundColor:0xffffff});
  app.view.style.position = "absolute";
  app.view.style.display = "block";
  document.body.appendChild(app.view);
  window.addEventListener('resize', resize);
  function resize(){
    //缩放
    ratio = Math.min(window.innerWidth/w,window.innerHeight/h);
    //这个是解决缩放后文字变模糊的核心所在，之前的用法是错误的！
    app.view.style.width = Math.ceil(w * ratio) + "px";
    app.view.style.height = Math.ceil(h * ratio) + "px";
    //app.renderer.resize(Math.ceil(w * ratio),Math.ceil(h * ratio));
    //所有的场景也要缩放
    //stage1.scale.x = stage1.scale.y = ratio;
    //stage2.scale.x = stage2.scale.y = ratio;
    //stage3.scale.x = stage3.scale.y = ratio;
    
    //居中
    var ratio2 = w/h;
    if(window.innerWidth/window.innerHeight>w/h){
      app.view.style.top = 0
      app.view.style.left = (window.innerWidth-window.innerHeight*ratio2)/2+'px'
    }else{
      app.view.style.left = 0
      app.view.style.top = (window.innerHeight-window.innerWidth/ratio2)/2+'px'
    }
  }
  resize();
  PIXI.SCALE_MODES.DEFAULT = PIXI.SCALE_MODES.NEAREST;
  app.ticker.add(function(delta) {
    myTicker(delta);
  });

  //创建容器（场景）
  var background = new PIXI.Container();
  var stage1     = new PIXI.Container();
  var stage2     = new PIXI.Container();
  var stage3     = new PIXI.Container();

  //各个场景中的状态改变器：
  function stage1_ticker(delta){

    //通过名字引用小鸟，不过这个名字需要自己定义好，这样子使用起来非常方便
    var niao = stage1.getChildByName('anim');
    niao.x += delta*2;
    if(niao.x> w+niao.width/2){
      niao.x = 0-niao.width/2;
    }

  }
  function stage2_ticker(){}
  function stage3_ticker(){}

  
  //场景1绘制
  function stage1_layout(res){

    //这个是清空场景作用
    //对于多次调用stage1_layout函数的时候，不会被反复地向舞台新增素材
    //如果要保持场景的状态，stage1_layout函数仅仅需要调用一次，切换场景的时候，只要把它隐藏就好了。
    stage1.removeChildren(0, stage1.children.length); 

    //创建背景图片
    bk =new PIXI.Sprite(PIXI.loader.resources.background.texture);
    bk.height = h;
    background.addChild(bk);

    //创建标题文字
    var title = new PIXI.Text('新交大群侠传',{
      fontFamily: 'Arial',
      fontSize: 100,
      fontStyle: 'italic',
      fontWeight: 'bold',
      fill: ['#ffffff', '#00ff99'], // gradient
      stroke: '#4a1850',
      strokeThickness: 5,
      dropShadow: true,
      dropShadowColor: '#000000',
      dropShadowBlur: 4,
      dropShadowAngle: Math.PI / 6,
      dropShadowDistance: 6,
      wordWrap: true,
      wordWrapWidth: 440
    });
    title.resolution = 2;
    title.anchor.set(.5)
    //注意，这里被坑了下，官方demo是没有resize的，所以用 app.screen.width 是可以的
    //其实我这里所有的定位，就根据最初的设定的w、h来进行处理就好
    //或者把 resize(); 放在这里之后。
    //title.x = app.screen.width/2;
    title.x = w/2;
    title.y = 100;

    //按钮文字1
    var btn1 = new PIXI.Text('GAME Start',{
      //fontFamily:"Conv_monogram",
      fontFamily:"Conv_Minecraftia-Regular",
      fontSize:32, 
      padding:20
    });
    btn1.anchor.set(.5)
    btn1.x = w/2;
    btn1.y = 300;
    btn1.interactive = true;
    btn1.buttonMode = true;
    btn1.on('pointerdown', function(){
      app.stage = stage2;
    });
    
    //按钮文字2
    var btn2 = new PIXI.Text('Author 介绍',{
      fontSize: 60
    });
    btn2.anchor.set(.5)
    btn2.x = w/2;
    btn2.y = 400;
    btn2.interactive = true;
    btn2.buttonMode = true;
    btn2.on('pointerdown', function(){
      app.stage = stage3;
      //注意这里一定要写上这两组，否者声音会被多次添加
      mySound.pause();
      mySound.play();
    });


    //暂停按钮
    var btn3 = new PIXI.Text('stop',{fontSize: 60}); 
    btn3.anchor.set(.5)
    btn3.x = w/2;
    btn3.y = 1000;
    btn3.interactive = true;
    btn3.buttonMode = true;
    btn3.on('pointerdown', function(){

      if(anim.playing){
        //状态改变器切换成空
        myTicker = function(){};
        //小鸟动画停止
        stage1.getChildByName('anim').stop();
        //修改文字
        btn3.setText("play")
      }else{
        //状态改变器切换成stage1_ticker
        myTicker = stage1_ticker
        //修改文字
        btn3.setText("stop")
        stage1.getChildByName('anim').play();
      }
    });



    //创建影片
    var n = Object.keys(res.monster.textures).length;
    var frames = [];
    for (var i = 0; i < n; i++) {
        frames.push(PIXI.Texture.fromFrame('frame-' + (i+1) + '.png'));
    }
    var anim = new PIXI.extras.AnimatedSprite(frames);
    anim.x = 100;
    anim.name="anim"; //起一个名字方便以后引用
    anim.y = app.screen.height / 2;
    anim.anchor.set(0.5);
    anim.animationSpeed = 0.25
    anim.play();
    //这个有点像flash中的实现
    //anim.gotoAndStop(2);

    

    //场景（容器）添加元素
    stage1.addChild(background,title,btn1,btn2,btn3,anim);
  }

  //场景2绘制
  function stage2_layout(res){   
      var btn = new PIXI.Text('游戏开始',{
        fontSize: 60,
        fill: 0x000,
        align: 'left'
      });
      btn.anchor.set(.5)
      btn.x = w/2;
      btn.y = 200;
      btn.interactive = true;
      btn.buttonMode = true;
      stage2.addChild(btn);
  }

  //场景3绘制
  function stage3_layout(res){

    // 如果加上下面这些，stage3被多次调用有重置场景的效果。看情况使用
    // stage3 = new PIXI.Container();
    // resize();
    
    var btn = new PIXI.Text('作者是一个画家，如果这里文字很长很长很长，我需要会折行的文字',{
      //下面三行是实现文字折行的重要配置
      //谷歌搜索 pixi text 查得 => https://pixijs.io/pixi-text-style/#
      "breakWords": true,
      "wordWrapWidth": w,
      "wordWrap": true
    });
    btn.anchor.set(.5)
    btn.x = w/2;
    btn.y = 200;
    btn.interactive = true;
    btn.buttonMode = true;

    var btn2 = new PIXI.Text('返回首页',{
      fontSize: 60,
      fill: 0x000,
      align: 'left'
    });
    btn2.anchor.set(.5)
    btn2.x = w/2;
    btn2.y = 400;
    btn2.interactive = true;
    btn2.buttonMode = true;
    btn2.on('pointerdown', function(){
      //如果再次调用这个布局函数的话，会进行重新布局，这样子，之前的动画啥的，就被清空了
      stage1_layout(res)
      
      app.stage = stage1;
    });
    stage3.addChild(btn);
    stage3.addChild(btn2);
  }



  //入口
  sounds.load([
    "sounds/music.wav",
    "sounds/splash.wav",
    "sounds/faerieFM.mp3",
    "sounds/alleySpectre.mp3"
  ]);
  sounds.whenLoaded = function(){
    //播放背景音乐（但是不会在手机中触发，手机中需要在点击中触发的，所以我要找一个地方来触发下，比如“开始游戏按钮”之类）
    mySound = sounds['sounds/faerieFM.mp3']
    mySound.loop = true; //其他属性设置可以参考官网（注意区分sound.js、soundJS，我们是前者）
    mySound.play(); //这个在手机上第一次的时候并不会被触发
    //mySound.playFrom(0); //控制具体从哪里开始播放

    //资源加载
    PIXI.loader
      .add("background", "background.png")
      .add("monster", "monster.json")
      .load(setup);
  };

  //加载后回调
  function setup(xxx,res) {

    //完成3个容器进行布局
    stage1_layout(res);
    stage2_layout(res);
    stage3_layout(res);
    
    //把容器1进行展示
    //app.stage.addChild(stage1);
    app.stage = stage1;
    //使用容器1对应的“状态改变器”
    myTicker = stage1_ticker;
    


  }



  //注意点：
  //1 就是字体显示模糊的问题，已经解决。坑了我很久
  //2 就是场景控制问题，
  //  1)比如只有一个场景，其他的内容都用容器的显示和隐藏来解决
  //  2)比如有多个场景，可以通过切换场景来进行
  //  3)那些内容是需要复位的，而那些是可以单独运行的，而时间计时器是如何在各个场景中运行的，这些都要搞明白
  //3 理解app.ticker.add，清空其回调，就是暂停。之前因为理解不够透彻，被坑了很久！
  

</script>

